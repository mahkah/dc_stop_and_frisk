<head>
  <meta charset='utf-8' />
  <title>DC Stop and Frisk Map</title>
  <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
  <script src='https://api.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js'></script>
  <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <link href="https://cdn.bootcss.com/noUiSlider/8.5.1/nouislider.min.css" rel="stylesheet">
  <script src="https://cdn.bootcss.com/noUiSlider/8.5.1/nouislider.js"></script>
  <link href='https://api.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css' rel='stylesheet' />

  <style>
  body {
    margin: 0;
    padding: 0;
    font-family: 'Helvetica Neue', Helvetica, Arial, Sans-serif;
    font-size: 13px;
    line-height: 14px;
  }
  h1 {
    font-size: 22px;
    line-height: 22px;
    text-align: center;
  }

  h2 {
    font-size: 16px;
    line-height: 16px;
    text-align: center;
  }
  h3 {
    font-size: 14px;
    line-height: 14px;
    margin-bottom: 1px;
  }
  h4 {
    font-size: 14px;
    line-height: 10px;
    text-align: center;
    margin: 5px;
  }
  a {
    text-decoration: none;
    color: #2dc4b2;
  }
  /*Map*/
  #map {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 100%;
  }
  /*Filter Control Console*/
  #filterConsole {
    position: absolute;
    width: 260px;
    margin: 10px;
    padding: 8px 16px;
    background-color: white;
    border-radius: 3px;
    border: 1px solid rgba(0,0,0,0.4);
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  }
  .map-overlay {
    position: absolute;
    bottom: 0;
    right: 0;
    background: rgba(255, 255, 255, 0.8);
    margin-right: 20px;
    font-family: Arial, sans-serif;
    overflow: auto;
    border-radius: 3px;
  }
  #filters {
    display: none;
  }
  #date-control {
    display: none;
  }
  /*Color Legend*/
  #legend {
    padding: 5px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    line-height: 16px;
    margin-bottom: 30px;
    right: -9px;
    border-radius: 3px;
    border: 1px solid rgba(0,0,0,0.4);
    font-size: 13px;
    font-family: 'Open Sans', sans-serif;
    visibility: hidden;
  }
  .legend-min {
    display: inline-block;
    float: left;
  }
  .legend-max {
    display: inline-block;
    float: right;
  }
  /*Layer Menu*/
  #menu {
    background: #fff;
    position: absolute;
    z-index: 1;
    top: 10px;
    right: 10px;
    border-radius: 3px;
    width: 120px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(0,0,0,0.4);
    font-family: 'Open Sans', sans-serif;
  }
  #menu a {
    font-size: 13px;
    color: #404040;
    display: block;
    margin: 0;
    padding: 0;
    padding: 10px;
    text-decoration: none;
    border-bottom: 1px solid rgba(0,0,0,0.25);
    text-align: center;
  }
  #menu a:last-child {
    border: none;
  }
  #menu a:hover {
    background-color: #f8f8f8;
    color: #404040;
  }
  #menu a.active {
    background-color: #3887be;
    color: #ffffff;
  }
  #menu a.active:hover {
    background: #3074a4;
  }
  /*Sliders*/
  #age-slider {
    height: 15px;
    width: 185px;
    margin: 3px auto 3px;
    float: right;
  }
  #date-slider {
    height: 15px;
    width: 260px;
    margin: 3px auto 10px;
    float: left;
  }
  .noUi-base .noUi-handle {
    margin-left: 10px;
    width: 10px;
  }
  .noUi-handle:before,
  .noUi-handle:after {
    left: 0px;
  }
  </style>
</head>

<body>

  <div id='map'></div>
  <nav id='menu'></nav>
  <div id='filterConsole'>
    <h1>Police Stops in Washington D.C.</h1>
    <h2>About the Data</h2>
    <p>
      This map visualizes <a href='https://mpdc.dc.gov/node/1310236'>the MPD's
      stop and frisk dataset</a>, which contains limited information about stops
      made from 2010 to 2017. Of these, 3050 stops could not be mapped due to
      missing or incomplete addresses.
    </p>
    <p>
      Read an <a href='https://github.com/GWarrenn'>analysis of this data</a>,
      explore <a href='https://github.com/mahkah/dc_stop_and_frisk/tree/master/transformed_data'>
      the underlying data</a>, or view
      <a href='https://github.com/mahkah/dc_stop_and_frisk/blob/master/index.html'>
      the source code</a>.
    </p>
    <p>
      Curious what facts gave police
      <a href='https://www.law.cornell.edu/wex/stop_and_frisk'>reasonable
        suspicion to make a stop</a>, or what stops escalated to frisks or
        arrests? Hold the MPD and Mayor Bowser accountable for <a href=''>
          failing to comply with data collection laws</a>.
    </p>
    <div id='filters'>
      <h2>Filter the Data</h2>
      <!--Race/Ethn Filter-->
      <div class='session' id='ethn-buttons'>
        <h3>Race/Ethnicity</h3>
        <div class='row' id='ethn-filters'>
          <input id='all-race' type='radio' name='toggle-race' value='All' checked='checked'>
          <label for='all-race'>All</label>
          <input id='black' type='radio' name='toggle-race' value='Black'>
          <label for='black'>Black</label>
          <input id='white' type='radio' name='toggle-race' value='White'>
          <label for='white'>White</label>
          <input id='hisp' type='radio' name='toggle-race' value='Hispanic or Latino'>
          <label for='hisp'>Hispanic or Latino</label>
          <input id='azn' type='radio' name='toggle-race' value='Asian'>
          <label for='azn'>Asian</label>
          <input id='other' type='radio' name='toggle-race' value='Other'>
          <label for='other'>Other</label>
        </div>
      </div>
      <!--Gender Filter-->
      <div class='session' id='gender-buttons'>
        <h3>Gender</h3>
        <div class='row' id='gender-filters'>
          <input id='all-gender' type='radio' name='toggle-gender' value='All' checked='checked'>
          <label for='all-gender'>All</label>
          <input id='male' type='radio' name='toggle-gender' value='Male'>
          <label for='male'>Men</label>
          <input id='women' type='radio' name='toggle-gender' value='Female'>
          <label for='women'>Women</label>
        </div>
      </div>
      <!--Age Filter-->
      <h3>Age: <label id='active-age'>Juveniles and Adults 18-75</label></h3>
      <input type="checkbox" id="juvenile-age" name="juvenile-age" value="juvenile-age" checked>
      <label for="juvenile-age">Juveniles</label>
      <div> <input type="checkbox" id="adult-age" name="adult-age" value="adult-age" checked>
      <label for="adult-age">Adults</label>
      <div id="age-slider"></div></div>
      <div></div>
      <!--Date Slider-->
      <div id=date-control>
        <h3>Date Range: <br>
        <label id ='event-start'>Friday, 1st January 2010</label> to <br><label id ='event-end'>Saturday, 31st December 2016</label></h3>
        <div id="date-slider"></div>
        <button class='btn' id='all-dates-btn'>Entire Period</button>
        <button class='btn' id='year-btn'>Year</button>
        <button class='btn' id='month-btn'>Month</button>
      </div>
    </div>
  </div>
  <div class='map-overlay' id='legend'>
    <div id='tooltip-heading'><h4>Region Information</h4></div>
    <div id='tooltip-info'><p>Hover over a region for more information.</p></div>
  </div>
  <script>
    // Build heading and color bar
    let vridis256 = ['#440154', '#440255', '#440357', '#450558', '#45065A',
      '#45085B', '#46095C', '#460B5E', '#460C5F', '#460E61', '#470F62', '#471163',
      '#471265', '#471466', '#471567', '#471669', '#47186A', '#48196B', '#481A6C',
      '#481C6E', '#481D6F', '#481E70', '#482071', '#482172', '#482273', '#482374',
      '#472575', '#472676', '#472777', '#472878', '#472A79', '#472B7A', '#472C7B',
      '#462D7C', '#462F7C', '#46307D', '#46317E', '#45327F', '#45347F', '#453580',
      '#453681', '#443781', '#443982', '#433A83', '#433B83', '#433C84', '#423D84',
      '#423E85', '#424085', '#414186', '#414286', '#404387', '#404487', '#3F4587',
      '#3F4788', '#3E4888', '#3E4989', '#3D4A89', '#3D4B89', '#3D4C89', '#3C4D8A',
      '#3C4E8A', '#3B508A', '#3B518A', '#3A528B', '#3A538B', '#39548B', '#39558B',
      '#38568B', '#38578C', '#37588C', '#37598C', '#365A8C', '#365B8C', '#355C8C',
      '#355D8C', '#345E8D', '#345F8D', '#33608D', '#33618D', '#32628D', '#32638D',
      '#31648D', '#31658D', '#31668D', '#30678D', '#30688D', '#2F698D', '#2F6A8D',
      '#2E6B8E', '#2E6C8E', '#2E6D8E', '#2D6E8E', '#2D6F8E', '#2C708E', '#2C718E',
      '#2C728E', '#2B738E', '#2B748E', '#2A758E', '#2A768E', '#2A778E', '#29788E',
      '#29798E', '#287A8E', '#287A8E', '#287B8E', '#277C8E', '#277D8E', '#277E8E',
      '#267F8E', '#26808E', '#26818E', '#25828E', '#25838D', '#24848D', '#24858D',
      '#24868D', '#23878D', '#23888D', '#23898D', '#22898D', '#228A8D', '#228B8D',
      '#218C8D', '#218D8C', '#218E8C', '#208F8C', '#20908C', '#20918C', '#1F928C',
      '#1F938B', '#1F948B', '#1F958B', '#1F968B', '#1E978A', '#1E988A', '#1E998A',
      '#1E998A', '#1E9A89', '#1E9B89', '#1E9C89', '#1E9D88', '#1E9E88', '#1E9F88',
      '#1EA087', '#1FA187', '#1FA286', '#1FA386', '#20A485', '#20A585', '#21A685',
      '#21A784', '#22A784', '#23A883', '#23A982', '#24AA82', '#25AB81', '#26AC81',
      '#27AD80', '#28AE7F', '#29AF7F', '#2AB07E', '#2BB17D', '#2CB17D', '#2EB27C',
      '#2FB37B', '#30B47A', '#32B57A', '#33B679', '#35B778', '#36B877', '#38B976',
      '#39B976', '#3BBA75', '#3DBB74', '#3EBC73', '#40BD72', '#42BE71', '#44BE70',
      '#45BF6F', '#47C06E', '#49C16D', '#4BC26C', '#4DC26B', '#4FC369', '#51C468',
      '#53C567', '#55C666', '#57C665', '#59C764', '#5BC862', '#5EC961', '#60C960',
      '#62CA5F', '#64CB5D', '#67CC5C', '#69CC5B', '#6BCD59', '#6DCE58', '#70CE56',
      '#72CF55', '#74D054', '#77D052', '#79D151', '#7CD24F', '#7ED24E', '#81D34C',
      '#83D34B', '#86D449', '#88D547', '#8BD546', '#8DD644', '#90D643', '#92D741',
      '#95D73F', '#97D83E', '#9AD83C', '#9DD93A', '#9FD938', '#A2DA37', '#A5DA35',
      '#A7DB33', '#AADB32', '#ADDC30', '#AFDC2E', '#B2DD2C', '#B5DD2B', '#B7DD29',
      '#BADE27', '#BDDE26', '#BFDF24', '#C2DF22', '#C5DF21', '#C7E01F', '#CAE01E',
      '#CDE01D', '#CFE11C', '#D2E11B', '#D4E11A', '#D7E219', '#DAE218', '#DCE218',
      '#DFE318', '#E1E318', '#E4E318', '#E7E419', '#E9E419', '#ECE41A', '#EEE51B',
      '#F1E51C', '#F3E51E', '#F6E61F', '#F8E621', '#FAE622', '#FDE724'].reverse();

    let viridisBar = '<span style="line-height: 0; display: inline-block; border: 1px solid black;">'
    vridis256.forEach(function(color) {
      viridisBar = viridisBar + '<span style="width: 1px; height: 20px; background-color: ' + color + '; display: inline-block;"></span>'
    });
    viridisBar = viridisBar + '</span>'
    let colorBar = document.createElement('div');
    colorBar.innerHTML = '<h4>Incident Count</h4>' + viridisBar;
    legend.appendChild(colorBar);
    // Create Numeric Labels
    let scale = document.createElement('div');
    let valueMin = document.createElement('span');
    valueMin.innerHTML = 0;
    valueMin.className = 'legend-min';
    scale.appendChild(valueMin);
    let valueMax = document.createElement('span');
    valueMax.innerHTML = 0;
    valueMax.className = 'legend-max';
    valueMax.id = 'legend-max';
    scale.appendChild(valueMax);
    legend.appendChild(scale);
    // Create Color Rescale Checkbox
    let scaleControl = document.createElement('div');
    scaleControl.innerHTML = '<br><input type="checkbox" id="filter-rescale" name="filter-rescale" value="filter-rescale" unchecked><label for="filter-rescale">Rescale color legend on filter change</label>'
    legend.appendChild(scaleControl);
  </script>


  <script>
  // Config
  mapboxgl.accessToken = 'pk.eyJ1IjoibWFoa2FoIiwiYSI6ImNqZW9zNHBvaTBhc2YzM2x0OWg3aXZ5dTAifQ.F1uwBes6jRJHdwqeSMiA-w';
  const branch = 'master'

  // Incident Data
  /*  Holds information about individual incidents and geographic features
  layerNames: Array containing names of Mapbox layer(s)
  label: Name of layer displayed on the map
  polygon: Whether or not a layer is a set of choropleth polygons
  geojsonFilename: Data file name
  defaultLayer: Whether or not is enabled by default
  mapboxSourceName: Name of mapbox source
  geojson: Geojson file containing incident data
  indices: Mutable sets to keep track of individual filtered incidents
  colorDefaultMax: Upper bound for choropleth color range
  */
  const mapLayers = {
    'indiv': {
      'layerNames': ['Individual Incidents', 'clusters', 'Individual Incidents Count'],
      'label': 'Individual Incidents',
      'polygon': false,
      'geojsonFilename': 'SF_Field_Contact_02202018_locations.geojson',
      'defaultLayer': true,
      'mapboxSourceName': 'sffcCluster'
    },
    'ward': {
      'layerNames': ['Wards'],
      'label': 'Wards',
      'polygon': true,
      'geojsonFilename': 'Ward_from_2012_collected.geojson',
      'defaultLayer': false,
      'mapboxSourceName': 'wards'
    },
    'neighborhood': {
      'layerNames': ['Neighborhoods'],
      'label': 'Neighborhoods',
      'polygon': true,
      'geojsonFilename': 'Neighborhood_Clusters_collected.geojson',
      'defaultLayer': false,
      'mapboxSourceName': 'neighborhoods'
    },
    'policeSector': {
      'layerNames': ['Police Sectors'],
      'label': 'Police Sectors',
      'polygon': true,
      'geojsonFilename': 'Police_Sectors_collected.geojson',
      'defaultLayer': false,
      'mapboxSourceName': 'policeSectors'
    },
    'psa': {
      'layerNames': ['Police Service Areas'],
      'label': 'Police Service Areas',
      'polygon': true,
      'geojsonFilename': 'Police_Service_Areas_collected.geojson',
      'defaultLayer': false,
      'mapboxSourceName': 'psas'
    },
    'censusTract': {
      'layerNames': ['Census Tracts'],
      'label': 'Census Tracts',
      'polygon': true,
      'geojsonFilename': 'Census_Tracts_in_2010_collected.geojson',
      'defaultLayer': false,
      'mapboxSourceName': 'censusTracts'
    }
  };
  Object.keys(mapLayers).forEach(function(key) {
    if(mapLayers[key].polygon === true) {
      mapLayers[key].colorDefaultMax = 0;
      mapLayers[key].indices = {};
    }
  });

  // Filters
  /* Define attributes to collect from individual incidents for filtering
  active: Whether a not a filter is being used
  mapboxFilter: Name of mapbox filter using built-in expressions
  clusterFilterFunction: Function used to filter the cluster layer
  choroplethFilterFunction: Function used to filter the choropleth layer*/
  const filterAttributes = {
    'race': {
      'active': false,
      'mapboxFilter': ['!=', ['string', ['get', 'race']], 'placeholder']
    },
    'gen': {
      'active': false,
      'mapboxFilter': ['!=', ['string', ['get', 'gen']], 'placeholder']
    },
    'age': {
      'active': false,
      'mapboxFilter': ['!=', ['number', ['get', 'age']], -10]
    },
    'yr': {
      'active': false,
      'mapboxFilter': ['!=', ['number', ['get', 'yr']], 25]
    },
    'hr': {
      'active': false,
      'mapboxFilter': ['!=', ['number', ['get', 'hr']], 25]
    },
  };
  const mapboxFilter = ['all']
  Object.keys(filterAttributes).forEach( function(attribute, i) {
    mapboxFilter.push(filterAttributes[attribute].mapboxFilter);
  });

  // Color Palettes, generated using Bokeh
  const viridis20 = ['#440154', '#471466', '#472575', '#453681', '#3F4587',
    '#39558B', '#32628D', '#2D6F8E', '#277C8E', '#23898D', '#1F968B',
    '#1FA286', '#29AF7F', '#3BBA75', '#53C567', '#72CF55', '#92D741',
    '#B7DD29', '#DAE218', '#FDE724'].reverse();
  const inferno20 = ['#000003', '#040316', '#10092F', '#1F0C47', '#32095D',
    '#450A69', '#550F6D', '#66156E', '#781C6D', '#88216A', '#992864',
    '#A92E5E', '#BA3655', '#C93F4A', '#D64A3F', '#E35832', '#ED6825',
    '#F37918', '#F98C09', '#FB9E07', '#FBB318', '#F8C931', '#F4DC4F',
    '#F1F079', '#FCFEA4'].reverse();
  const cividis20 = ['#00204C', '#002963', '#00316F', '#1E3C6C', '#33456B',
    '#444F6B', '#51586C', '#5E626E', '#6A6C71', '#757575', '#828078',
    '#8F8A78', '#9D9577', '#AAA074', '#B8AB70', '#C7B76A', '#D5C263',
    '#E5CF5A', '#F4DC4E', '#FFE945'].reverse();

  // Misc helper variables
  let activePolygonLayer = ''; //contains mapLayer key for active choropleth layer
  let filterRescale = false; //whether or not choropleth fill colors should rescale based on the filters



  function loadData(key, branch) {
    return new Promise(function(resolve, reject) {
      $.ajax({
        url:"https://raw.githubusercontent.com/mahkah/dc_stop_and_frisk/" + branch + "/transformed_data/" + mapLayers[key].geojsonFilename,
        dataType: "json",
        success: function(result) {
          resolve(result);
        },
        error: function(xhr) {
          reject(xhr);
        }
      });
    });
  }


  // loadData('indiv', branch).then(function(v) {
  //   console.log(mapLayers.indiv.geojsonFilename + " successfully loaded.");
  //   mapLayers.indiv.geojson = v;
  //
  //
  // })
  // .catch(function(v) {
  //   throw v;
  // })








   //http://www.macadamian.com/2017/04/11/javascript-promises-explained/
   //https://stackoverflow.com/questions/14220321/how-do-i-return-the-response-from-an-asynchronous-call?noredirect=1&lq=1
  // function indivCallback() {
  //   mapLayers[key].geojson = result;
  //
  //   loadMap()
  //
  //   onMapLoad() {
  //     plotindiv()
  //     filters()
  //     loadData() {
  //       plotchoropleth()
  //       buildLayerMenu()
  //     }
  //   }
  // }








  // Build HTML Elements
  const ageSlider = document.getElementById('age-slider');
  noUiSlider.create(ageSlider, {
    range: {
      'min': 18,
      'max': 75
    },
    start: [ 18, 75 ],
    step: 1,
    margin: 0,
    connect: true,
    direction: 'ltr',
    orientation: 'horizontal',
    behaviour: 'tap-drag'
  });

  const dateSlider = document.getElementById('date-slider');
  function timestamp(str){
    return new Date(str).getTime();
  }
  const dateMin = timestamp('2010') + (5 * 60 * 60 * 1000); // 5 Hours is for EST?
  const dateMax = timestamp('2017')
  noUiSlider.create(dateSlider, {
    range: {
      'min': dateMin,
      'max': dateMax
    },
    start: [timestamp('2010'), timestamp('2017')],
    step: 30 * 24 * 60 * 60 * 1000,
    connect: true,
    direction: 'ltr',
    orientation: 'horizontal',
    behaviour: 'tap-drag'
  });


  // Load map
  const map = new mapboxgl.Map({
    container: 'map', // container element id
    style: 'mapbox://styles/mapbox/light-v9',
    center: [-77.030034, 38.901863], // initial map center in [lon, lat]
    zoom: 11
  });




  // Data Layers
  map.on('load', async function() {
    mapLayers.indiv.geojson = await loadData('indiv', branch);
    console.log(mapLayers.indiv.geojsonFilename + " successfully loaded.");

    // Incident Cluster Layer
    map.addSource(mapLayers.indiv.mapboxSourceName, {
      type: 'geojson',
      data: mapLayers.indiv.geojson,
      cluster: true,
      clusterMaxZoom: 29,
      clusterRadius: 30
    });
    // Single Incidents
    map.addLayer({
      id: mapLayers.indiv.layerNames[0],
      type: 'circle',
      source: mapLayers.indiv.mapboxSourceName,
      filter: mapboxFilter,
      paint: {
        "circle-color": inferno20[0],
        "circle-radius": 4,
        "circle-stroke-width": 1,
        "circle-stroke-color": "#111",
        "circle-opacity": 0.8
      }
    }, 'admin-2-boundaries-dispute');
    // Clusters
    map.addLayer({
      id: mapLayers.indiv.layerNames[1],
      type: "circle",
      source: mapLayers.indiv.mapboxSourceName,
      filter:  ['all', ["has", "point_count"]],
      paint: {
        "circle-color": [
          "interpolate",
          ["exponential", 2.5],
          ["get", "point_count"],
          1, inferno20[0],
          6, inferno20[1],
          16, inferno20[2],
          32, inferno20[3],
          56, inferno20[4],
          88, inferno20[5],
          130, inferno20[6],
          181, inferno20[7],
          243, inferno20[8],
          316, inferno20[9],
          401, inferno20[10],
          499, inferno20[11],
          609, inferno20[12],
          733, inferno20[13],
          871, inferno20[14],
          1024, inferno20[15],
          1192, inferno20[16],
          1375, inferno20[17],
          1574, inferno20[18],
          1789, inferno20[19]
        ],
        "circle-radius": [
          "interpolate",
          ["exponential", 2.5],
          ["get", "point_count"],
          1, 5,
          6, 6,
          16, 7,
          32, 8,
          56, 9,
          88, 10,
          130, 11,
          181, 12,
          243, 13,
          316, 14,
          401, 15,
          499, 16,
          609, 17,
          733, 18,
          871, 19,
          1024, 20,
          1192, 21,
          1375, 22,
          1574, 23,
          1789, 24
        ],
        'circle-opacity': 0.8
      }
    });
    // Cluster Labels
    map.addLayer({
      id: mapLayers.indiv.layerNames[2],
      type: "symbol",
      source: mapLayers.indiv.mapboxSourceName,
      filter:  ['all', ["has", "point_count"]],
      layout: {
        "text-field": "{point_count_abbreviated}",
        "text-font": ["DIN Offc Pro Medium", "Arial Unicode MS Bold"],
        "text-size": 12
      }
    });



    // Filters
    // Stop Type Filter
    // document.getElementById('stop_filters').addEventListener('change', function(e) {
    //   singleValueFilter('stop', e.target.value);
    // });
    // Ethnicity Filter
    document.getElementById('ethn-filters').addEventListener('change', function(e) {
      singleValueFilter('race', e.target.value);
    });
    // Gender Filter
    document.getElementById('gender-filters').addEventListener('change', function(e) {
      singleValueFilter('gen', e.target.value);
    });
    // Age Fliter
    document.getElementById('juvenile-age').addEventListener('change', ageFilter);
    document.getElementById('adult-age').addEventListener('change', ageFilter);
    ageSlider.noUiSlider.on('update', ageFilterText);
    ageSlider.noUiSlider.on('change', function() {
      document.getElementById("adult-age").checked = true;
      ageFilter();
    });
    // Date Filter

    /** Applies filters that call for a datafield to match a specific value*/
    function singleValueFilter(attribute, value) {
      filterAttributes[attribute].active = (value != 'All');
      if (value === 'All') {
        // Single Incidents
        filterAttributes[attribute].mapboxFilter = ['!=', ['string', ['get', attribute]], 'placeholder'];
      } else {
        // Single Incidents
        filterAttributes[attribute].mapboxFilter = ['match', ['get', attribute], value, true, false];
        filterAttributes[attribute].clusterFilterFunction = function(i) {return i.properties[attribute] === value;}
        // Choropleth layers
        Object.keys(mapLayers).forEach(function(key) {
          if(mapLayers[key].polygon) {singleValueIndices(key, attribute, value);}
        });
      }
      filterUpdate();
    }

    /** Updates the age label filter displayed in HTML*/
    function ageFilterText() {
      if(document.getElementById('adult-age').checked) {
        const ageLowerBound = parseInt(ageSlider.noUiSlider.get()[0]);
        const ageUpperBound = parseInt(ageSlider.noUiSlider.get()[1]);
        if(document.getElementById('juvenile-age').checked) {document.getElementById('active-age').innerText = 'Juveniles and Adults ' + ageLowerBound + '-' + ageUpperBound;}
        else {document.getElementById('active-age').innerText = 'Adults ' + ageLowerBound + '-' + ageUpperBound;}
      }
      else {
        if(document.getElementById('juvenile-age').checked) {document.getElementById('active-age').innerText = 'Juveniles';}
        else {document.getElementById('active-age').innerText = 'Select Juveniles and/or Adults';}
      }
    }

    /** Applies the age filter*/
    function ageFilter() {
      ageFilterText()
      const ageLowerBound = parseInt(ageSlider.noUiSlider.get()[0]);
      const ageUpperBound = parseInt(ageSlider.noUiSlider.get()[1]);
      filterAttributes.age.active = !(ageLowerBound === 18 && ageUpperBound === 75 && document.getElementById('adult-age').checked && document.getElementById('juvenile-age').checked);
      if(document.getElementById('adult-age').checked) {
        if(document.getElementById('juvenile-age').checked) {
          // Single Incidents
          filterAttributes.age.mapboxFilter = ['any',
            ['==', ['number', ['get', 'age']], 0],
            ['all',
              ['>=', ['number', ['get', 'age']], ageLowerBound],
              ['<=', ['number', ['get', 'age']], ageUpperBound]
            ]
          ];
          filterAttributes.age.clusterFilterFunction = function(i) { return i.properties.age === 0 || (i.properties.age >= ageLowerBound && i.properties.age <= ageUpperBound);}
          // Choropleth layers
          filterAttributes.age.choroplethFilterFunction = function(i) {return i === 0 || (i >= ageLowerBound && i <= ageUpperBound);}
        } else {
          // Single Incidents
          filterAttributes.age.mapboxFilter = ['all',
            ['>=', ['number', ['get', 'age']], ageLowerBound],
            ['<=', ['number', ['get', 'age']], ageUpperBound]
          ];
          filterAttributes.age.clusterFilterFunction = function(i) { return i.properties.age >= ageLowerBound && i.properties.age <= ageUpperBound;}
          // Choropleth layers
          filterAttributes.age.choroplethFilterFunction = function(i) { return i >= ageLowerBound && i <= ageUpperBound;}
        }
        Object.keys(mapLayers).forEach(function(key) {
          if(mapLayers[key].polygon === true) {functionValueIndices(key, 'age');}
        });
        // Refresh Filters
        filterUpdate();
      } else {
        const age = document.getElementById('juvenile-age').checked ? 0 : -10
        singleValueFilter('age', age)
      }
    };

    // Date Slider
    let dateValues = [
    	document.getElementById('event-start'),
    	document.getElementById('event-end')
    ];

    dateSlider.noUiSlider.on('update', function(values, handle) {
    	dateFilterText(values, handle);
    });

    document.getElementById('all-dates-btn').addEventListener('click', function(e) {
      dateFilterText([dateMin, dateMax], 0);
      dateFilterText([dateMin, dateMax], 1);
      dateSlider.noUiSlider.set([dateMin, dateMax]);
    });

    document.getElementById('year-btn').addEventListener('click', function(e) {
      let currentMin = dateSlider.noUiSlider.get()[0];
      let newMin = Number(currentMin);
      let newMax = newMin + (365 * 24 * 60 * 60 * 1000);
      if(newMax > dateMax) {
        newMax = dateMax;
        newMin = newMax - (365 * 24 * 60 * 60 * 1000);
      }

      dateFilterText([newMin, newMax], 0);
      dateFilterText([newMin, newMax], 1);
      dateSlider.noUiSlider.set([newMin, newMax]);
    });

    document.getElementById('month-btn').addEventListener('click', function(e) {
      let currentMin = dateSlider.noUiSlider.get()[0];
      let newMin = Number(currentMin);
      let newMax = newMin + (30 * 24 * 60 * 60 * 1000);
      if(newMax > dateMax) {
        newMax = dateMax;
        newMin = newMax - (30 * 24 * 60 * 60 * 1000);
      }

      dateFilterText([newMin, newMax], 0);
      dateFilterText([newMin, newMax], 1);
      dateSlider.noUiSlider.set([newMin, newMax]);
    });

    function dateFilterText(values, handle) {
      dateValues[handle].innerHTML = formatDate(new Date(+values[handle]));
    }

    // Append a suffix to dates.
    // Example: 23 => 23rd, 1 => 1st.
    function nth (d) {
      if(d>3 && d<21) return 'th';
      switch (d % 10) {
        case 1:  return "st";
        case 2:  return "nd";
        case 3:  return "rd";
        default: return "th";
      }
    }

    // Create a string representation of the date.
    function formatDate (date) {
      const weekdays = [
      		"Sunday", "Monday", "Tuesday",
      		"Wednesday", "Thursday", "Friday",
      		"Saturday"
      	];
      const	months = [
      		"January", "February", "March",
      		"April", "May", "June", "July",
      		"August", "September", "October",
      		"November", "December"
      	];
      return weekdays[date.getDay()] + ", " +
        date.getDate() + nth(date.getDate()) + " " +
        months[date.getMonth()] + " " +
        date.getFullYear();
    }

    // Turn on filter control
    filters.style.display = 'inline'

    // Choropleth Maps
    polygonLayers(branch);

    /** Loads polygon datasets, plots them, and builds menu for toggling them */
    async function polygonLayers(branch) {
      let polygonGeojsons = [];
      Object.keys(mapLayers).forEach(function(key) {
        if(mapLayers[key].polygon) {polygonGeojsons.push(plotChoropleth(key, branch));}
      });
      await Promise.all(polygonGeojsons);

      // Build layer selection menu and associated elements
      Object.keys(mapLayers).forEach(function(key) {
        // Build buttons for each layer
        const link = document.createElement('a');
        link.href = '#';
        if (mapLayers[key].defaultLayer === true) {
          link.className = 'active';
        } else {
          link.className = '';
        }
        link.textContent = mapLayers[key].label;
        link.id = key
        // Add interactivity
        link.onclick = function(e) {
          const clickedLayer = this.id;
          e.preventDefault();
          e.stopPropagation();
          const visibility = map.getLayoutProperty(mapLayers[clickedLayer].layerNames[0], 'visibility');
          if (visibility === 'visible') {
            this.className = '';
            for (let i = 0; i < mapLayers[clickedLayer].layerNames.length; i++) {
              map.setLayoutProperty(mapLayers[clickedLayer].layerNames[i], 'visibility', 'none');
            }
            if(mapLayers[clickedLayer].polygon) {activePolygonLayer = '';}
          } else {
            this.className = 'active';
            if(mapLayers[clickedLayer].polygon) {refreshChoropleth(clickedLayer);}
            for (let i = 0; i < mapLayers[clickedLayer].layerNames.length; i++) {
              map.setLayoutProperty(mapLayers[clickedLayer].layerNames[i], 'visibility', 'visible');
            }
            //Turn off the current polygon layer, if applicable
            if(mapLayers[clickedLayer].polygon) {
              if(activePolygonLayer) {
                document.getElementById(activePolygonLayer).className = '';
                map.setLayoutProperty(mapLayers[activePolygonLayer].layerNames[0], 'visibility', 'none');
              }
              activePolygonLayer = clickedLayer;
            }
          }
          // Toggle Legend
          legend.style.visibility = (activePolygonLayer) ? 'visible' : 'hidden';
        };
        document.getElementById('menu').appendChild(link)
      });
    }

    /** Loads and plots choropleth maps. */
    async function plotChoropleth(key, branch) {
      mapLayers[key].geojson = await loadData(key, branch);
      console.log(mapLayers[key].geojsonFilename + " successfully loaded.");

      let maxSFFC = 0
      for (let i = 0; i < mapLayers[key].geojson.features.length; i++) {
        mapLayers[key].geojson.features[i].properties.sffcCount = mapLayers[key].geojson.features[i].properties.hr.length;
        if (mapLayers[key].geojson.features[i].properties.sffcCount > maxSFFC) {
          maxSFFC = mapLayers[key].geojson.features[i].properties.sffcCount;
        }
      }
      mapLayers[key].colorDefaultMax = maxSFFC;
      mapLayers[key].colorRange = [];
      for (let i = 0; i < 20; i++) {
        mapLayers[key].colorRange[i] = maxSFFC * (i / 19);
      }

      map.addSource(mapLayers[key].mapboxSourceName, {
        type: 'geojson',
        data: mapLayers[key].geojson
      });
      map.addLayer({
        'id': mapLayers[key].layerNames[0],
        'type': 'fill',
        'source': mapLayers[key].mapboxSourceName,
        'paint': {
          'fill-color': [
            'interpolate',
            ['linear'],
            ['get', 'sffcCount'],
            mapLayers[key].colorRange[0], viridis20[0],
            mapLayers[key].colorRange[1], viridis20[1],
            mapLayers[key].colorRange[2], viridis20[2],
            mapLayers[key].colorRange[3], viridis20[3],
            mapLayers[key].colorRange[4], viridis20[4],
            mapLayers[key].colorRange[5], viridis20[5],
            mapLayers[key].colorRange[6], viridis20[6],
            mapLayers[key].colorRange[7], viridis20[7],
            mapLayers[key].colorRange[8], viridis20[8],
            mapLayers[key].colorRange[9], viridis20[9],
            mapLayers[key].colorRange[10], viridis20[10],
            mapLayers[key].colorRange[11], viridis20[11],
            mapLayers[key].colorRange[12], viridis20[12],
            mapLayers[key].colorRange[13], viridis20[13],
            mapLayers[key].colorRange[14], viridis20[14],
            mapLayers[key].colorRange[15], viridis20[15],
            mapLayers[key].colorRange[16], viridis20[16],
            mapLayers[key].colorRange[17], viridis20[17],
            mapLayers[key].colorRange[18], viridis20[18],
            mapLayers[key].colorRange[19], viridis20[19]
          ],
          'fill-opacity': 0.7,
          'fill-outline-color': 'white'
        }
      }, 'Individual Incidents')
      map.setLayoutProperty(mapLayers[key].layerNames[0], 'visibility', 'none');
    }
  }); // End of on map load actions

  // Tooltip
  map.on('mousemove', function(e) {
    if(activePolygonLayer) {
      let incident = map.queryRenderedFeatures(e.point, {
        layers: mapLayers[activePolygonLayer].layerNames
      });
      if (incident.length > 0) {
        document.getElementById('tooltip-info').innerHTML = '<p>' + incident[0].properties.sffcCount + ' police stops<p>';
      } else {
        document.getElementById('tooltip-info').innerHTML = '<p>Hover over a region for more information.</p>';
      }
    }
  });

  // Legend Checkbox
  //if(filterRescale) {document.getElementById('filter-rescale').checked = true;}
  document.getElementById('filter-rescale').addEventListener('change', function() {
      filterRescale = document.getElementById('filter-rescale').checked
      colorRescale(activePolygonLayer);
      document.getElementById('legend-max').innerHTML = Math.floor(mapLayers[activePolygonLayer].colorRange[19]);
  });


  // Helper Functions
  /** Takes the intersection of two or more sets. */
  function intersect(sets) {
    let minSize = sets[0].size;
    let shortSetIndex = 0;
    for (let i = 1; i < sets.length; i++) {
      if (sets[i].size < minSize) {
        minSize = sets[i].size;
        shortSetIndex = i;
      }
    }
    // let shortSetIndex = sets.reduce(function(minI,el,i,arr) {return el.size<arr[minI].size ? i : minI;}, 0);
    let shortSet = sets.splice(shortSetIndex, 1);
    let count = sets.length;
    let result = new Set(shortSet[0]);
    shortSet[0].forEach(item => {
      let i = count;
      let allHave = true;
      while (i--){
        allHave = sets[i].has(item)
        if (!allHave) { break }
      }
      if (!allHave) {
        result.delete(item);
      }
    })
    return result;
  }

  /** Updates the specified choropleth layer according to the new map layers. */
  function refreshChoropleth(key) {
    // Compute values for each region
    for (let i = 0; i < mapLayers[key].geojson.features.length; i++) {
      let indicesSets = [];
      Object.keys(filterAttributes).forEach( function(attribute) {
        if (filterAttributes[attribute].active) {indicesSets.push(mapLayers[key].indices[attribute][i]);}
      });
      if (indicesSets.length === 0) {
        var intersectionIndices = new Set(Array.apply(null, {length: mapLayers[key].geojson.features[i].properties.race.length}).map(Number.call, Number));
      } else if (indicesSets.length === 1) {
        var intersectionIndices = indicesSets[0];
      } else {
        var intersectionIndices = intersect(indicesSets);
      }
      mapLayers[key].geojson.features[i].properties.sffcCount = intersectionIndices.size;
    }
    // Send values to map
    map.getSource(mapLayers[key].mapboxSourceName).setData(mapLayers[key].geojson);
    // Rescale colors as needed
    if(filterRescale || mapLayers[key].colorDefaultMax != mapLayers[key].colorRange[19]) {
      colorRescale(key);
    }
    // Set legend
    document.getElementById('legend-max').innerHTML = Math.floor(mapLayers[key].colorRange[19]);
  }

  /** Rescales choropleth fill colors based on the filtered dataset */
  function colorRescale(key) {
    if(filterRescale) {
      var maxSFFC = 0;
      for (let i = 0; i < mapLayers[key].geojson.features.length; i++) {
        if (mapLayers[key].geojson.features[i].properties.sffcCount > maxSFFC) {
          maxSFFC = mapLayers[key].geojson.features[i].properties.sffcCount;
        }
      }
    } else {
      var maxSFFC = mapLayers[key].colorDefaultMax;
    }
    if(maxSFFC < 19) {maxSFFC = 19;}
    mapLayers[key].colorRange = [];
    for (let i = 0; i < 20; i++) {
      mapLayers[key].colorRange[i] = maxSFFC * (i / 19);
    }
    map.setPaintProperty(mapLayers[key].layerNames[0], 'fill-color', [
      'interpolate',
      ['linear'],
      ['get', 'sffcCount'],
      mapLayers[key].colorRange[0], viridis20[0],
      mapLayers[key].colorRange[1], viridis20[1],
      mapLayers[key].colorRange[2], viridis20[2],
      mapLayers[key].colorRange[3], viridis20[3],
      mapLayers[key].colorRange[4], viridis20[4],
      mapLayers[key].colorRange[5], viridis20[5],
      mapLayers[key].colorRange[6], viridis20[6],
      mapLayers[key].colorRange[7], viridis20[7],
      mapLayers[key].colorRange[8], viridis20[8],
      mapLayers[key].colorRange[9], viridis20[9],
      mapLayers[key].colorRange[10], viridis20[10],
      mapLayers[key].colorRange[11], viridis20[11],
      mapLayers[key].colorRange[12], viridis20[12],
      mapLayers[key].colorRange[13], viridis20[13],
      mapLayers[key].colorRange[14], viridis20[14],
      mapLayers[key].colorRange[15], viridis20[15],
      mapLayers[key].colorRange[16], viridis20[16],
      mapLayers[key].colorRange[17], viridis20[17],
      mapLayers[key].colorRange[18], viridis20[18],
      mapLayers[key].colorRange[19], viridis20[19]
    ]);
  }

  /** Updates the individual layers according to the new map layers. */
  function filterUpdate() {
    // Single incidents
    map.setFilter('Individual Incidents', mapboxFilter);
    // Cluster Layer
    let clusterData = mapLayers.indiv.geojson.features;
    Object.keys(filterAttributes).forEach( function(attribute) {
      if(filterAttributes[attribute].active) {clusterData = clusterData.filter(filterAttributes[attribute].clusterFilterFunction);}
    });
    map.getSource('sffcCluster').setData(turf.featureCollection(clusterData));
    // Choropleth layers
    if(activePolygonLayer) {refreshChoropleth(activePolygonLayer);}
  }

  //** Modifies the sets of indices to match a particular variable */
  function singleValueIndices(key, attribute, value) {
    mapLayers[key].indices[attribute] = [];
    for (let i = 0; i < mapLayers[key].geojson.features.length; i++) {
      mapLayers[key].indices[attribute][i] = new Set();
      let j = mapLayers[key].geojson.features[i].properties[attribute].indexOf(value);
      while (j != -1) {
        mapLayers[key].indices[attribute][i].add(j);
        j = mapLayers[key].geojson.features[i].properties[attribute].indexOf(value, j + 1);
      }
    }
  }

  //** Modifies the sets of indices according to a function */
  function functionValueIndices(key, attribute) {
    mapLayers[key].indices[attribute] = [];
    for (let i = 0; i < mapLayers[key].geojson.features.length; i++) {
      mapLayers[key].indices[attribute][i] = new Set();
      let j = mapLayers[key].geojson.features[i].properties[attribute].findIndex(filterAttributes[attribute].choroplethFilterFunction);
      let k = j;
      while (k != -1) {
        mapLayers[key].indices[attribute][i].add(j);
        k = mapLayers[key].geojson.features[i].properties[attribute].slice(j + 1).findIndex(filterAttributes[attribute].choroplethFilterFunction);
        j = j + 1 + k;
      }
    }
  }

  </script>
</body>
