<head>
  <meta charset='utf-8' />
  <title>DC Stop and Frisk Map</title>
  <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
  <script src='https://api.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js'></script>
  <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <link href="https://cdn.bootcss.com/noUiSlider/8.5.1/nouislider.min.css" rel="stylesheet">
  <script src="https://cdn.bootcss.com/noUiSlider/8.5.1/nouislider.js"></script>
  <link href='https://api.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css' rel='stylesheet' />

  <style>
  body {
    margin: 0;
    padding: 0;
    font-family: 'Helvetica Neue', Helvetica, Arial, Sans-serif;
  }

  #map {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 100%;
  }
  /*No UI Slider*/
  #range-slider {
    height: 15px;
    width: 152px;
    margin: 3px auto 3px;
    float: right;
  }
  </style>
</head>

<body>
  <style>
  h1 {
    font-size: 20px;
    line-height: 30px;
  }

  h2 {
    font-size: 18px;
    line-height: 26px;
  }
  h3 {
    font-size: 14px;
    line-height: 20px;
    margin-bottom: 10px;
  }
  a {
    text-decoration: none;
    color: #2dc4b2;
  }
  #console {
    position: absolute;
    width: 240px;
    margin: 10px;
    padding: 10px 20px;
    background-color: white;
  }
  .map-overlay {
    position: absolute;
    bottom: 0;
    right: 0;
    background: rgba(255, 255, 255, 0.8);
    margin-right: 20px;
    font-family: Arial, sans-serif;
    overflow: auto;
    border-radius: 3px;
  }

  #legend {
    padding: 10px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    line-height: 18px;
    height: 130px;
    margin-bottom: 40px;
    width: 250px;
  }
  .legend-key {
    display: inline-block;
    border-radius: 20%;
    width: 10px;
    height: 10px;
    margin-right: 5px;
  }

  #menu {
    background: #fff;
    position: absolute;
    z-index: 1;
    top: 10px;
    right: 10px;
    border-radius: 3px;
    width: 120px;
    border: 1px solid rgba(0,0,0,0.4);
    font-family: 'Open Sans', sans-serif;
  }
  #menu a {
    font-size: 13px;
    color: #404040;
    display: block;
    margin: 0;
    padding: 0;
    padding: 10px;
    text-decoration: none;
    border-bottom: 1px solid rgba(0,0,0,0.25);
    text-align: center;
  }
  #menu a:last-child {
    border: none;
  }
  #menu a:hover {
    background-color: #f8f8f8;
    color: #404040;
  }
  #menu a.active {
    background-color: #3887be;
    color: #ffffff;
  }
  #menu a.active:hover {
    background: #3074a4;
  }
  </style>

  <div id='map'></div>
  <nav id='menu'></nav>
  <div id='console'>
    <h1>Stop and Frisks</h1>
    <p>Data: <a href='https://mpdc.dc.gov/node/1310236'>Stop and frisk incidents</a> in Washington DC, 2010-2016</p>

    <h2>Filters</h2>
    <!--Race/Ethn Filter-->
    <div class='session' id='ethn_buttons'>
      <h3>Race/Ethnicity</h3>
      <div class='row' id='ethn_filters'>
        <input id='all_race' type='radio' name='toggle_race' value='All' checked='checked'>
        <label for='all_race'>All</label>
        <input id='black' type='radio' name='toggle_race' value='Black'>
        <label for='black'>Black</label>
        <input id='white' type='radio' name='toggle_race' value='White'>
        <label for='white'>White</label>
        <input id='hisp' type='radio' name='toggle_race' value='Hispanic or Latino'>
        <label for='hisp'>Hispanic or Latino</label>
        <input id='azn' type='radio' name='toggle_race' value='Asian'>
        <label for='azn'>Asian</label>
        <input id='other' type='radio' name='toggle_race' value='Other'>
        <label for='other'>Other</label>
      </div>
    </div>
    <!--Gender Filter-->
    <div class='session' id='gender_buttons'>
      <h3>Gender</h3>
      <div class='row' id='gender_filters'>
        <input id='all_gender' type='radio' name='toggle_gender' value='All' checked='checked'>
        <label for='all_gender'>All</label>
        <input id='male' type='radio' name='toggle_gender' value='Male'>
        <label for='male'>Men</label>
        <input id='women' type='radio' name='toggle_gender' value='Female'>
        <label for='women'>Women</label>
      </div>
    </div>
    <!--Age Filter-->
    <h3>Age: <label id='active-age'>Juveniles and Adults 18-75</label></h3>
    <input type="checkbox" id="juvenile_age" name="juvenile_age" value="juvenile_age" checked>
    <label for="juvenile_age">Juveniles</label>
    <div> <input type="checkbox" id="adult_age" name="adult_age" value="adult_age" checked>
    <label for="adult_age">Adults</label>
    <div id="range-slider"></div></div>
    <div></div>
    <!--Year Filter-->
    <div class='session' id='sliderbar'>
      <h3>Year: <label id='active-year'>All Years</label></h3>
      <button class='btn' id='all_years_btn'>All Years</button>
      <input id='year_slider' class='row' type='range' min='2010' max='2016' step='1' value='2016'/>
    </div>
    <!--Hour Filter-->
    <div class='session' id='sliderbar'>
      <h3>Hour: <label id='active-hour'>All Times</label></h3>
      <button class='btn' id='all_time_btn'>All Times</button>
      <input id='time_slider' class='row' type='range' min='0' max='23' step='1' value='22'/>
    </div>
    <!--Date Slider-->
    <h3>Date Range: <label id='active-date'>Entire Period</label></h3>
    <div id="date-slider"></div>
    <p>Value: <label id ='event-start'>Not moved</label> to <label id ='event-end'>Not moved</label></p>
    <!--
    <h2>Info</h2>
    <div id='pd'><p>Hover over an incident for more information.</p></div>
    -->
  </div>

  <div class='map-overlay' id='legend'></div>


  <script>
  // Config
  mapboxgl.accessToken = 'pk.eyJ1IjoibWFoa2FoIiwiYSI6ImNqZW9zNHBvaTBhc2YzM2x0OWg3aXZ5dTAifQ.F1uwBes6jRJHdwqeSMiA-w';

  // Initialize Datasets
  // Filters
  /* Define attributes to collect from individual incidents for filtering
  active: Whether a not a filter is being used
  mapboxFilter: Name of mapbox filter using built-in expressions
  clusterFilterFunction: Function used to filter the cluster layer
  choroplethFilterFunction: Function used to filter the choropleth layer*/
  var filterAttributes = {
    'race': {
      'active': false,
      'mapboxFilter': ['!=', ['string', ['get', 'race']], 'placeholder']
    },
    'gen': {
      'active': false,
      'mapboxFilter': ['!=', ['string', ['get', 'gen']], 'placeholder']
    },
    'age': {
      'active': false,
      'mapboxFilter': ['!=', ['number', ['get', 'age']], -10]
    },
    'yr': {
      'active': false,
      'mapboxFilter': ['!=', ['number', ['get', 'yr']], 25]
    },
    'mon': {
      'active': false,
      'mapboxFilter': ''
    },
    'day': {
      'active': false,
      'mapboxFilter': ''
    },
    'hr': {
      'active': false,
      'mapboxFilter': ['!=', ['number', ['get', 'hr']], 25]
    },
  };

  // Incident Data
  /*  Holds information about individual incidents and geographic features
  layerNames: Array containing names of Mapbox layer(s)
  label: Name of layer displayed on the map
  polygon: Whether or not a layer is a set of choropleth polygons
  geojsonFilename: Data file name
  defaultLayer: Whether or not is enabled by default
  mapboxSourceName: Name of mapbox source
  geojson: Geojson file containing incident data
  indices: Mutable sets to keep track of individual filtered incidents
  maxSFFC: Upper bound for choropleth color range
  */
  var mapLayers = {
    'indiv': {
      'layerNames': ['Individual Incidents', 'clusters', 'Individual Incidents Count'],
      'label': 'Individual Incidents',
      'polygon': false,
      'geojsonFilename': 'SF_Field_Contact_02202018_locations.geojson',
      'defaultLayer': true,
      'mapboxSourceName': 'sffc_cluster'
    },
    'ward': {
      'layerNames': ['Wards'],
      'label': 'Wards',
      'polygon': true,
      'geojsonFilename': 'Ward_from_2012_collected.geojson',
      'defaultLayer': false,
      'mapboxSourceName': 'wards'
    },
    'neighborhood': {
      'layerNames': ['Neighborhoods'],
      'label': 'Neighborhoods',
      'polygon': true,
      'geojsonFilename': 'Neighborhood_Clusters_collected.geojson',
      'defaultLayer': false,
      'mapboxSourceName': 'neighborhoods'
    },
    'policeSector': {
      'layerNames': ['Police Sectors'],
      'label': 'Police Sectors',
      'polygon': true,
      'geojsonFilename': 'Police_Sectors_collected.geojson',
      'defaultLayer': false,
      'mapboxSourceName': 'policeSectors'
    },
    'psa': {
      'layerNames': ['Police Service Areas'],
      'label': 'Police Service Areas',
      'polygon': true,
      'geojsonFilename': 'Police_Service_Areas_collected.geojson',
      'defaultLayer': false,
      'mapboxSourceName': 'psas'
    },
    'censusTract': {
      'layerNames': ['Census Tracts'],
      'label': 'Census Tracts',
      'polygon': true,
      'geojsonFilename': 'Census_Tracts_in_2010_collected.geojson',
      'defaultLayer': false,
      'mapboxSourceName': 'censusTracts'
    }
  };

  // Load data and build data driven properties of mapLayers
  Object.keys(mapLayers).forEach(function(key) {
    $.ajax({
      url:"https://raw.githubusercontent.com/mahkah/dc_stop_and_frisk/master/transformed_data/" + mapLayers[key].geojsonFilename,
      dataType: "json",
      success: function(result) {
        // geojson Property
        mapLayers[key].geojson = result;
        // Polygon only properties
        if(mapLayers[key].polygon === true) {
          mapLayers[key].maxSFFC = 0;
          mapLayers[key].indices = {}
        }
        console.log(mapLayers[key].geojsonFilename + " successfully loaded.");
      },
      error: function (xhr) {
        alert(xhr.statusText);
      }
    });
  });
  var activePolygonLayer = ''

  /** Takes the intersection of two or more sets. */
  function intersect(sets) {
    var minSize = sets[0].size;
    var shortSetIndex = 0;
    for (var i = 1; i < sets.length; i++) {
      if (sets[i].size < minSize) {
        minSize = sets[i].size;
        shortSetIndex = i;
      }
    }
    // var shortSetIndex = sets.reduce(function(minI,el,i,arr) {return el.size<arr[minI].size ? i : minI;}, 0);
    var shortSet = sets.splice(shortSetIndex, 1);
    var count = sets.length;
    var result = new Set(shortSet[0]);
    shortSet[0].forEach(item => {
      var i = count;
      var allHave = true;
      while (i--){
        allHave = sets[i].has(item)
        if (!allHave) { break }
      }
      if (!allHave) {
        result.delete(item);
      }
    })
    return result;
  }

  /** Updates the specified choropleth layer according to the new map layers. */
  function refreshChoropleth(key) {
    for (var i = 0; i < mapLayers[key].geojson.features.length; i++) {
      var indicesSets = [];
      Object.keys(filterAttributes).forEach( function(attribute) {
        if (filterAttributes[attribute].active) {indicesSets.push(mapLayers[key].indices[attribute][i]);}
      });
      if (indicesSets.length === 0) {
        var intersection_indices = new Set(Array.apply(null, {length: mapLayers[key].geojson.features[i].properties.race.length}).map(Number.call, Number));
      } else if (indicesSets.length === 1) {
        var intersection_indices = indicesSets[0]
      } else {
        var intersection_indices = intersect(indicesSets);
      }
      mapLayers[key].geojson.features[i].properties.sffcCount = intersection_indices.size;
    }
    map.getSource(mapLayers[key].mapboxSourceName).setData(mapLayers[key].geojson);
    //Color Rescaling
    // if(true === false) {
    //   var maxSFFC = 0;
    //   for (var i = 0; i < mapLayers[key].geojson.features.length; i++) {
    //     if (mapLayers[key].geojson.features[i].properties.sffcCount > maxSFFC) {
    //       maxSFFC = mapLayers[key].geojson.features[i].properties.sffcCount;
    //     }
    //   }
    //   var colorRange = []
    //   for (var i = 0; i < 20; i++) {
    //     colorRange[i] = maxSFFC * (i / 19);
    //   }
    //   map.setPaintProperty(mapLayers[key].layerNames[0], 'fill-color', [
    //     'interpolate',
    //     ['linear'],
    //     ['get', 'sffcCount'],
    //     colorRange[0], 'rgb(253,231,37)',
    //     colorRange[1], 'rgb(220,228,23)',
    //     colorRange[2], 'rgb(184,222,41)',
    //     colorRange[3], 'rgb(147,216,64)',
    //     colorRange[4], 'rgb(116,208,85)',
    //     colorRange[5], 'rgb(85,198,102)',
    //     colorRange[6], 'rgb(60,188,117)',
    //     colorRange[7], 'rgb(41,175,127)',
    //     colorRange[8], 'rgb(33,163,134)',
    //     colorRange[9], 'rgb(32,150,139)',
    //     colorRange[10], 'rgb(35,137,141)',
    //     colorRange[11], 'rgb(40,124,142)',
    //     colorRange[12], 'rgb(45,112,142)',
    //     colorRange[13], 'rgb(50,99,142)',
    //     colorRange[14], 'rgb(57,84,140)',
    //     colorRange[15], 'rgb(63,71,136)',
    //     colorRange[16], 'rgb(69,55,129)',
    //     colorRange[17], 'rgb(72,39,119)',
    //     colorRange[18], 'rgb(72,21,104)',
    //     colorRange[19], 'rgb(68,13,83)'
    //   ]);
    // }
  }

  /** Updates the individual layers according to the new map layers. */
  function filterUpdate() {
    // Single incidents
    map.setFilter('Individual Incidents', ['all', filterAttributes.race.mapboxFilter, filterAttributes.gen.mapboxFilter, filterAttributes.age.mapboxFilter, filterAttributes.yr.mapboxFilter, filterAttributes.hr.mapboxFilter]);
    // Cluster Layer
    var clusterData = mapLayers.indiv.geojson.features;
    Object.keys(filterAttributes).forEach( function(attribute) {
      if(filterAttributes[attribute].active) {clusterData = clusterData.filter(filterAttributes[attribute].clusterFilterFunction);}
    });
    var clusterData = turf.featureCollection(clusterData);
    map.getSource('sffc_cluster').setData(clusterData);
    // Choropleth layers
    if(activePolygonLayer) {refreshChoropleth(activePolygonLayer);}
  }

  //** Modifies the sets of indices to match a particular variable */
  function singleValueFilter(key, attribute, value) {
    mapLayers[key].indices[attribute] = [];
    for (var i = 0; i < mapLayers[key].geojson.features.length; i++) {
      mapLayers[key].indices[attribute][i] = new Set();
      var j = mapLayers[key].geojson.features[i].properties[attribute].indexOf(value);
      while (j != -1) {
        mapLayers[key].indices[attribute][i].add(j);
        j = mapLayers[key].geojson.features[i].properties[attribute].indexOf(value, j + 1);
      }
    }
  }

  //** Modifies the sets of indices according to a function */
  function functionValueFilter(key, attribute) {
    mapLayers[key].indices[attribute] = [];
    for (var i = 0; i < mapLayers[key].geojson.features.length; i++) {
      mapLayers[key].indices[attribute][i] = new Set();
      var j = mapLayers[key].geojson.features[i].properties[attribute].findIndex(filterAttributes[attribute].choroplethFilterFunction);
      var k = j;
      while (k != -1) {
        mapLayers[key].indices[attribute][i].add(j);
        k = mapLayers[key].geojson.features[i].properties[attribute].slice(j + 1).findIndex(filterAttributes[attribute].choroplethFilterFunction);
        j = j + 1 + k;
      }
    }
  }

  // Build HTML Elements
  var rangeSlider = document.getElementById('range-slider');
  noUiSlider.create(rangeSlider, {
    range: {
      'min': 18,
      'max': 75
    },
    start: [ 18, 75 ],
    step: 1,
    margin: 0,
    connect: true,
    direction: 'ltr',
    orientation: 'horizontal',
    behaviour: 'tap-drag'
  });

  var dateSlider = document.getElementById('date-slider');
  function timestamp(str){
    return new Date(str).getTime();
  }
  noUiSlider.create(dateSlider, {
    range: {
      'min': timestamp('2010'),
      'max': timestamp('2011')
    },
    start: [ timestamp('2010'), timestamp('2011') ],
    step: 7 * 24 * 60 * 60 * 1000,
    connect: true,
    direction: 'ltr',
    orientation: 'horizontal',
    behaviour: 'tap-drag'
  });

  var dateValues = [
  	document.getElementById('event-start'),
  	document.getElementById('event-end')
  ];

  dateSlider.noUiSlider.on('update', function( values, handle ) {
    console.log(values);
    console.log(handle);
    console.log(dateValues[handle].innerHTML);
  	dateValues[handle].innerHTML = formatDate(new Date(+values[handle]));
  });



  // Append a suffix to dates.
  // Example: 23 => 23rd, 1 => 1st.
  function nth (d) {
    if(d>3 && d<21) return 'th';
    switch (d % 10) {
      case 1:  return "st";
      case 2:  return "nd";
      case 3:  return "rd";
      default: return "th";
    }
  }

  // Create a string representation of the date.
  function formatDate (date) {
    var weekdays = [
    		"Sunday", "Monday", "Tuesday",
    		"Wednesday", "Thursday", "Friday",
    		"Saturday"
    	];
    var	months = [
    		"January", "February", "March",
    		"April", "May", "June", "July",
    		"August", "September", "October",
    		"November", "December"
    	];
    return weekdays[date.getDay()] + ", " +
      date.getDate() + nth(date.getDate()) + " " +
      months[date.getMonth()] + " " +
      date.getFullYear();
  }

  // Load map
  var map = new mapboxgl.Map({
    container: 'map', // container element id
    style: 'mapbox://styles/mapbox/light-v9',
    center: [-77.030034, 38.901863], // initial map center in [lon, lat]
    zoom: 11
  });

  // Data Layers
  map.on('load', function() {
    // Incident Cluster Layer
    map.addSource(mapLayers.indiv.mapboxSourceName, {
      type: 'geojson',
      data: mapLayers.indiv.geojson,
      cluster: true,
      clusterMaxZoom: 29,
      clusterRadius: 30
    });
    // Single Incidents
    map.addLayer({
      id: mapLayers.indiv.layerNames[0],
      type: 'circle',
      source: mapLayers.indiv.mapboxSourceName,
      filter: ['all', filterAttributes.race.mapboxFilter, filterAttributes.gen.mapboxFilter, filterAttributes.age.mapboxFilter, filterAttributes.yr.mapboxFilter, filterAttributes.hr.mapboxFilter],
      paint: {
        "circle-color": "rgb(253,231,37)",
        "circle-radius": 4,
        "circle-stroke-width": 1,
        "circle-stroke-color": "#111",
        "circle-opacity": 0.7
      }
    }, 'admin-2-boundaries-dispute'
  );
  // Clusters
  map.addLayer({
    id: mapLayers.indiv.layerNames[1],
    type: "circle",
    source: mapLayers.indiv.mapboxSourceName,
    filter:  ['all', ["has", "point_count"]],
    paint: {
      "circle-color": [
        "interpolate",
        ["exponential", 2.5],
        ["get", "point_count"],
        1, 'rgb(253,231,37)',
        6, 'rgb(220,228,23)',
        16, 'rgb(184,222,41)',
        32, 'rgb(147,216,64)',
        56, 'rgb(116,208,85)',
        88, 'rgb(85,198,102)',
        130, 'rgb(60,188,117)',
        181, 'rgb(41,175,127)',
        243, 'rgb(33,163,134)',
        316, 'rgb(32,150,139)',
        401, 'rgb(35,137,141)',
        499, 'rgb(40,124,142)',
        609, 'rgb(45,112,142)',
        733, 'rgb(50,99,142)',
        871, 'rgb(57,84,140)',
        1024, 'rgb(63,71,136)',
        1192, 'rgb(69,55,129)',
        1375, 'rgb(72,39,119)',
        1574, 'rgb(72,21,104)',
        1789, 'rgb(68,13,83)'
      ],
      "circle-radius": [
        "interpolate",
        ["exponential", 2.5],
        ["get", "point_count"],
        1, 5,
        6, 6,
        16, 7,
        32, 8,
        56, 9,
        88, 10,
        130, 11,
        181, 12,
        243, 13,
        316, 14,
        401, 15,
        499, 16,
        609, 17,
        733, 18,
        871, 19,
        1024, 20,
        1192, 21,
        1375, 22,
        1574, 23,
        1789, 24
      ],
      'circle-opacity': 0.7
    }
  });
  // Cluster Labels
  map.addLayer({
    id: mapLayers.indiv.layerNames[2],
    type: "symbol",
    source: mapLayers.indiv.mapboxSourceName,
    filter:  ['all', ["has", "point_count"]],
    layout: {
      "text-field": "{point_count_abbreviated}",
      "text-font": ["DIN Offc Pro Medium", "Arial Unicode MS Bold"],
      "text-size": 12
    }
  });

  // Choropleth Maps
  Object.keys(mapLayers).forEach(function(key) {
    if(mapLayers[key].polygon === true) {plotChoropleth(key);}
  });

  /** Plots choropleth maps. */
  async function plotChoropleth(key) {
    for (var i = 0; i < mapLayers[key].geojson.features.length; i++) {
      mapLayers[key].geojson.features[i].properties.sffcCount = mapLayers[key].geojson.features[i].properties.hr.length;
      if (mapLayers[key].geojson.features[i].properties.sffcCount > mapLayers[key].maxSFFC) {
        mapLayers[key].maxSFFC = mapLayers[key].geojson.features[i].properties.sffcCount;
      }
    }
    mapLayers[key].maxSFFCUnfiltered = mapLayers[key].maxSFFC;
    mapLayers[key].colorRange = [];
    for (var i = 0; i < 20; i++) {
      mapLayers[key].colorRange[i] = mapLayers[key].maxSFFC * (i / 19);
    }
    map.addSource(mapLayers[key].mapboxSourceName, {
      type: 'geojson',
      data: mapLayers[key].geojson
    });
    map.addLayer({
      'id': mapLayers[key].layerNames[0],
      'type': 'fill',
      'source': mapLayers[key].mapboxSourceName,
      'paint': {
        'fill-color': [
          'interpolate',
          ['linear'],
          ['get', 'sffcCount'],
          mapLayers[key].colorRange[0], 'rgb(253,231,37)',
          mapLayers[key].colorRange[1], 'rgb(220,228,23)',
          mapLayers[key].colorRange[2], 'rgb(184,222,41)',
          mapLayers[key].colorRange[3], 'rgb(147,216,64)',
          mapLayers[key].colorRange[4], 'rgb(116,208,85)',
          mapLayers[key].colorRange[5], 'rgb(85,198,102)',
          mapLayers[key].colorRange[6], 'rgb(60,188,117)',
          mapLayers[key].colorRange[7], 'rgb(41,175,127)',
          mapLayers[key].colorRange[8], 'rgb(33,163,134)',
          mapLayers[key].colorRange[9], 'rgb(32,150,139)',
          mapLayers[key].colorRange[10], 'rgb(35,137,141)',
          mapLayers[key].colorRange[11], 'rgb(40,124,142)',
          mapLayers[key].colorRange[12], 'rgb(45,112,142)',
          mapLayers[key].colorRange[13], 'rgb(50,99,142)',
          mapLayers[key].colorRange[14], 'rgb(57,84,140)',
          mapLayers[key].colorRange[15], 'rgb(63,71,136)',
          mapLayers[key].colorRange[16], 'rgb(69,55,129)',
          mapLayers[key].colorRange[17], 'rgb(72,39,119)',
          mapLayers[key].colorRange[18], 'rgb(72,21,104)',
          mapLayers[key].colorRange[19], 'rgb(68,13,83)'
        ],
        'fill-opacity': 0.6,
        'fill-outline-color': 'black'
      }
    }, 'Individual Incidents')
    map.setLayoutProperty(mapLayers[key].layerNames[0], 'visibility', 'none');
  }

  // Filters
  // Ethnicity Filter
  document.getElementById('ethn_filters').addEventListener('change', function(e) {
    var race = e.target.value;
    filterAttributes.race.active = race != 'All';
    if (race === 'All') {
      // Single Incidents
      filterAttributes.race.mapboxFilter = ['!=', ['string', ['get', 'race']], 'placeholder'];
    } else {
      // Single Incidents
      filterAttributes.race.mapboxFilter = ['match', ['get', 'race'], race, true, false];
      filterAttributes.race.clusterFilterFunction = function(i) {return i.properties.race === race;}
      // Choropleth layers
      Object.keys(mapLayers).forEach(function(key) {
        if(mapLayers[key].polygon) {singleValueFilter(key, 'race', race);}
      });
    }
    filterUpdate();
  });

  // Gender Filter
  document.getElementById('gender_filters').addEventListener('change', function(e) {
    var gen = e.target.value;
    filterAttributes.gen.active = gen != 'All';
    if (gen === 'All') {
      // Single Incidents
      filterAttributes.gen.mapboxFilter = ['!=', ['string', ['get', 'gen']], 'placeholder'];
    } else {
      // Single Incidents
      filterAttributes.gen.mapboxFilter = ['match', ['get', 'gen'], gen, true, false];
      filterAttributes.gen.clusterFilterFunction = function(i) {return i.properties.gen === gen;}
      // Choropleth layers
      Object.keys(mapLayers).forEach(function(key) {
        if(mapLayers[key].polygon === true) {singleValueFilter(key, 'gen', gen);}
      });
    }
    filterUpdate();
  });

  // Age Fliter
  document.getElementById('juvenile_age').addEventListener('change', ageFilter);
  document.getElementById('adult_age').addEventListener('change', ageFilter);
  rangeSlider.noUiSlider.on('update', ageFilterText);
  rangeSlider.noUiSlider.on('change', function() {
    document.getElementById("adult_age").checked = true;
    ageFilter();
  });

  /** Updates the age label filter displayed in HTML*/
  function ageFilterText() {
    if(document.getElementById('adult_age').checked) {
      var ageLowerBound = parseInt(rangeSlider.noUiSlider.get()[0]);
      var ageUpperBound = parseInt(rangeSlider.noUiSlider.get()[1]);
      if(document.getElementById('juvenile_age').checked) {document.getElementById('active-age').innerText = 'Juveniles and Adults ' + ageLowerBound + '-' + ageUpperBound;}
      else {document.getElementById('active-age').innerText = 'Adults ' + ageLowerBound + '-' + ageUpperBound;}
    }
    else {
      if(document.getElementById('juvenile_age').checked) {document.getElementById('active-age').innerText = 'Juveniles';}
      else {document.getElementById('active-age').innerText = 'Select Juveniles and/or Adults';}
    }
  }

  /** Applies the age filter*/
  function ageFilter() {
    ageFilterText()
    var ageLowerBound = parseInt(rangeSlider.noUiSlider.get()[0]);
    var ageUpperBound = parseInt(rangeSlider.noUiSlider.get()[1]);
    filterAttributes.age.active = !(ageLowerBound === 18 && ageUpperBound === 75 && document.getElementById('adult_age').checked && document.getElementById('juvenile_age').checked);
    if(document.getElementById('adult_age').checked) {
      if(document.getElementById('juvenile_age').checked) {
        // Single Incidents
        filterAttributes.age.mapboxFilter = ['any', ['==', ['number', ['get', 'age']], 0], ['all', ['>=', ['number', ['get', 'age']], ageLowerBound], ['<=', ['number', ['get', 'age']], ageUpperBound]]];
        filterAttributes.age.clusterFilterFunction = function(i) { return i.properties.age === 0 || (i.properties.age >= ageLowerBound && i.properties.age <= ageUpperBound);}
        // Choropleth layers
        filterAttributes.age.choroplethFilterFunction = function(i) {return i === 0 || (i >= ageLowerBound && i <= ageUpperBound);}
        Object.keys(mapLayers).forEach(function(key) {
          if(mapLayers[key].polygon === true) {functionValueFilter(key, 'age');}
        });
        // Refresh Filters
        filterUpdate();
      } else {
        // Single Incidents
        filterAttributes.age.mapboxFilter = ['all', ['>=', ['number', ['get', 'age']], ageLowerBound], ['<=', ['number', ['get', 'age']], ageUpperBound]];
        filterAttributes.age.clusterFilterFunction = function(i) { return i.properties.age >= ageLowerBound && i.properties.age <= ageUpperBound;}
        // Choropleth layers
        filterAttributes.age.choroplethFilterFunction = function(i) { return i >= ageLowerBound && i <= ageUpperBound;}
        Object.keys(mapLayers).forEach(function(key) {
          if(mapLayers[key].polygon === true) {functionValueFilter(key, 'age');}
        });
        // Refresh Filters
        filterUpdate();
      }
    } else {
      if(document.getElementById('juvenile_age').checked) {
        var age = 0
        // Single Incidents
        filterAttributes.age.mapboxFilter = ['==', ['number', ['get', 'age']], age];
        filterAttributes.age.clusterFilterFunction = function(i) {return i.properties.age === age;}
        // Choropleth layers
        Object.keys(mapLayers).forEach(function(key) {
          if(mapLayers[key].polygon) {singleValueFilter(key, 'age', age);}
        });
        // Refresh Filters
        filterUpdate();
      } else {
        var age = -10
        // Single Incidents
        filterAttributes.age.mapboxFilter = ['==', ['number', ['get', 'age']], age];
        filterAttributes.age.clusterFilterFunction = function(i) {return i.properties.age === age;}
        // Choropleth layers
        Object.keys(mapLayers).forEach(function(key) {
          if(mapLayers[key].polygon === true) {singleValueFilter(key, 'age', age);}
        });
        // Refresh Filters
        filterUpdate();
      }
    }
  };

  // Year Slider
  document.getElementById('year_slider').addEventListener('input', function(e) {
    var yr = parseInt(e.target.value);
    filterAttributes.yr.active = true;
    // Update Filter Control's Display
    document.getElementById('active-year').innerText = yr;
    // Single Incidents
    filterAttributes.yr.mapboxFilter = ['==', ['number', ['get', 'yr']], yr];
    filterAttributes.yr.clusterFilterFunction = function(i) {return i.properties.yr === yr;}
    // Choropleth layers
    Object.keys(mapLayers).forEach(function(key) {
      if(mapLayers[key].polygon === true) {singleValueFilter(key, 'yr', yr);}
    });
    // Refresh Filters
    filterUpdate();
  });

  // All Years Button
  document.getElementById('all_years_btn').addEventListener('click', function(e) {
    filterAttributes.yr.active = false;
    // Update Filter Control's Display
    document.getElementById('active-year').innerText = 'All Years';
    // Single Incidents
    filterAttributes.yr.mapboxFilter = ['!=', ['number', ['get', 'yr']], 25];
    // Refresh Filters
    filterUpdate();
  });

  // Hour Slider
  document.getElementById('time_slider').addEventListener('input', function(e) {
    var hour = parseInt(e.target.value);
    filterAttributes.hr.active = true
    // Update Filter Control's Display
    var ampm = hour >= 12 ? 'PM' : 'AM';
    var hour12 = hour % 12 ? hour % 12 : 12;
    document.getElementById('active-hour').innerText = hour12 + ampm;
    // Single Incidents
    filterAttributes.hr.mapboxFilter = ['==', ['number', ['get', 'hr']], hour];
    filterAttributes.hr.clusterFilterFunction = function(i) {return i.properties.hr === hour;}
    // Choropleth layers
    Object.keys(mapLayers).forEach(function(key) {
      if(mapLayers[key].polygon === true) {singleValueFilter(key, 'hr', hour);}
    });
    // Refresh Filters
    filterUpdate();
  });

  // All Time Button
  document.getElementById('all_time_btn').addEventListener('click', function(e) {
    filterAttributes.hr.active = false;
    // Update Filter Control's Display
    document.getElementById('active-hour').innerText = 'All Times';
    // Single Incidents
    filterAttributes.hr.mapboxFilter = ['!=', ['number', ['get', 'hour']], 25];
    // Refresh Filters
    filterUpdate();
  });

  // // Build Legend
  // var layers = ['White', 'Black', 'Asian', 'American Indian/Alaska Native', 'Native Hawaiian/Other Pacific Islander', 'Unknown'];
  // var colors = ['#fbb03b', '#223b53', '#3bb2d0', '#3bb2d0', '#3bb2d0', '#111111'];
  // for (i = 0; i < layers.length; i++) {
  //   var layer = layers[i];
  //   var color = colors[i];
  //   var item = document.createElement('div');
  //   var key = document.createElement('span');
  //   key.className = 'legend-key';
  //   key.style.backgroundColor = color;
  //   var value = document.createElement('span');
  //   value.innerHTML = layer;
  //   item.appendChild(key);
  //   item.appendChild(value);
  //   legend.appendChild(item);
  // }

}); // End of on map load actions

// Tooltip
// map.on('mousemove', function(e) {
//   var incident = map.queryRenderedFeatures(e.point, {
//     layers: ['Individual Incidents']
//   });
//
//   if (incident.length > 0) {
//     document.getElementById('pd').innerHTML = '<h3><strong>' + incident[0].properties.gen + '</strong></h3>';
//   } else {
//     document.getElementById('pd').innerHTML = '<p>Hover over an incident for more information.</p>';
//   }
// });

// Layer Selection
Object.keys(mapLayers).forEach(function(key) {
  // Build buttons for each layer
  var link = document.createElement('a');
  link.href = '#';
  if (mapLayers[key].defaultLayer === true) {
    link.className = 'active';
  } else {
    link.className = '';
  }
  link.textContent = mapLayers[key].label;
  link.id = key
  // Add interactivity
  link.onclick = function(e) {
    var clickedLayer = this.id;
    e.preventDefault();
    e.stopPropagation();
    var visibility = map.getLayoutProperty(mapLayers[clickedLayer].layerNames[0], 'visibility');
    if (visibility === 'visible') {
      this.className = '';
      for (var i = 0; i < mapLayers[clickedLayer].layerNames.length; i++) {
        map.setLayoutProperty(mapLayers[clickedLayer].layerNames[i], 'visibility', 'none');
      }
      if(mapLayers[clickedLayer].polygon) {activePolygonLayer = '';}
    } else {
      this.className = 'active';
      if(mapLayers[clickedLayer].polygon) {refreshChoropleth(clickedLayer);}
      for (var i = 0; i < mapLayers[clickedLayer].layerNames.length; i++) {
        map.setLayoutProperty(mapLayers[clickedLayer].layerNames[i], 'visibility', 'visible');
      }
      //Turn off the current polygon layer, if applicable
      if(mapLayers[clickedLayer].polygon === true) {
        if(activePolygonLayer) {
          document.getElementById(activePolygonLayer).className = '';
          map.setLayoutProperty(mapLayers[activePolygonLayer].layerNames[0], 'visibility', 'none');
        }
        activePolygonLayer = clickedLayer;
      }
    }
  };
  var layers = document.getElementById('menu');
  layers.appendChild(link);
});

</script>
</body>
